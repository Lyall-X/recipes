# 设计模式
```
设计原则：
1. 高内聚，低耦合
2. 面向对象：封装、继承和多态
3. 面向接口：组合优于继承
4. solid原则：
    单一职责原则
    开闭原则
    里氏替换原则
    接口隔离原则
    依赖倒置原则
```
## 一、创建型模式
### 1.1 Factory 模式
1. 定义创建对象的接口，封装了对象的创建
2. 使得具体化类的工作延迟到了子类中
3. 一个工厂造所有
### 1.2 AbstactFactory 模式
1. 同样是封装了对象的创建过程，并且具体化类的工作延迟到了子类
2. 不同是的抽象工作是具有多个维度的划分，依靠扩展工厂类型实现
3. 实现出发点，可以从工厂的类别划分开始(工厂的类别实际是item的类别)，然后归纳出工厂的共性
4. 最终关注点从item的类别和创建过长，转移到了工厂的类别
5. 不同工厂造所有
需要扩展的维度和接口会很多
### 1.3 Singleton 模式
1. 引入全局变量
### 1.4 Builder 模式
1. 拆解复杂的构造函数，组合树，或复杂对象
2. 实现不同的创建过程实现不同的产品结果
### 1.5 Prototype 模式
1. 提供复制对象的Clone方法
2. 子类的区别如果只是对象的初始化，那么适合用clone
## 二、结构型模式
### 2.1 Bridge 模式
1. 继承如果维度多，会导致几何倍增长
2. 组合优于继承，通过组合不同的维度
3. 将庞大的类进行拆分: 1.具体部分(实现业务功能) 2抽象部分(底层最基本的api)
### 2.2 Adapter 模式
1. 创建中间层
### 2.3 Decorator 模式
1. 装饰器需要和被装饰对象有同样的子类
2. 没经过一层装饰器，原指针的内容就会被修改一次
3. 注意每多一层装饰器，在调用的时候就会从下往上再来一次
### 2.4 Composite 模式
1. 用组建的方式，将不同功能整合到一起
2. 适用于树状结构对象
3. 适合以相同的方式，处理复杂的对象
### 2.5 Flyweight 模式
1. 将众多对象中中相同的部分抽离出来，用于减少创建对象的数量，减少内存占用和提高性能
2. 享元对象可在不同的情景中使用，确保其状态不能被修改
3. 有点像单例，目标是实现相同的对象的复用
### 2.6 Facade 模式
1. 需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式
### 2.7 Proxy 模式
1. 延迟初始化（虚拟代理）
2. 访问控制（保护代理）
3. 本地执行远程服务（远程代理）
4. 记录日志请求（日记代理）
5. 智能引用
## 三、行为模式
### 3.1 Template 模式
1. 抽象步骤必须由各个子类来实现，希望只拓展某几个步骤，并且多个算法只有细微的差别时
2. 可选步骤已有一些默认实现，但仍可在需要时进行重写
### 3.2 Strategy 模式
### 3.3 State 模式
### 3.4 Observer 模式
### 3.5 Memento 模式
### 3.6 Mediator 模式
1. 当对象与其他对象紧密耦合，难以修改时使用
2. 当组件因过于依赖其他组件而无法在不同应用中复用时
3. 如果为了能在不同情景下复用一些基本行为，导致你需要被迫创建大量组件子类时，可使用中介者模式
### 3.7 Command 模式
1. 请求将命令方法参数化，表现为将类或函数作为命令存储与传递
2. 延迟请求执行或将其放入队列中
3. 命令可撤销操作
### 3.8 Visitor 模式
1. 对复杂对象结构(对象树)中，所有元素执行访问
2. 将非主要的工作，放到访问者类中
3. 当某个行为只在一些类中有意义，其他类中没意义，可放到访问者中
4. 注意梳理访问者与被访问者的维度
### 3.9 Chain of Responsibility 模式
1. 当必须按顺序执行多个处理者时
2. 类似有右键操作，被一层层UI捕获
### 3.10 Iterator 模式
1. 集合背后为复杂的数据结构，希望对客户端隐藏其复杂性
2. 减少程序出现重复的遍历代码
3. 希望遍历不同的，甚至无法预知的数据结构
### 3.11 Interpreter 模式